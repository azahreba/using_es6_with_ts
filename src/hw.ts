/// <reference path="../typings/tsd.d.ts" />

/*
 *
 * */
import log from './module';
console.log('in here');
log();

import $ from 'jquery';

$('body').css({'background': '#6bad6c'});
/*
*
* const vs namespace
*
* */
{
    const obj = {a: 1};
    obj.a = 2; // sets a prop to 2;

    // module has been replaced with namespace: TS >= 1.5
    // Internal - Named Module => IIFE
    namespace ts.NameSpace {
        export const a = 1;
    }

    // namespace is accessible only if something is exported
    ts.NameSpace.a = 3; // Error

    // in the same file
    import ns = ts.NameSpace;

    // from another file if namespace is not exported
    /// <reference path="ns.ts" />
}
/*
*
* let/const function + annotate params
*
* */
{
    const greetArrow = (name/*Error: param has any type */) => {
        return "Hello, " + name;
    };
}
// by let or const TS can manage dead zones
{
    console.log(greetArrowTs('Dead zone'));
}

// can't bind this with arrow function
// arrow function isn't new-able
{
    const greetArrowTs = (name: string) => "Hello, " + name;
}

/*
*
* Destructuring
*
* interface objects/functions that will be exported
* use in objects, arrays
* pass params using destructuring and annotate them with type
*
* */
{
    // code contract
    interface USPostalAddress /* could extend another interface*/ {
        city: string,
        state?: string, /* optional */
        zip: number,
        setAddress(): void
    }

    interface Fn {
        (x: number): number;
    }

    function iFn (num: number): number {
        return num * 100;
    }

    var fn: Fn = iFn;

    // interface an object or object that is returned by function
    interface Obj {
        name: string;
        setAge: (years: number) => number;
    }


    const address:USPostalAddress = {
        city: 'NY',
        zip: 12345,
    };

    // could be used as function params
    // take care about handling undefined props in parent obj
    let {city:/* as */ c = 'LA by default'} = address;

    const numbers:number[] = [1, 2, 3];
    const strings:string[] = ['a', 'b', 'c'];

    const [first = 0, second, ...rest] = numbers || [];

    const res = [...numbers, ...strings];
}

/*
 * Classes combined with interfaces
 * */
{
    class Engine {
        constructor(public horsePower: number,
                    public engineType: string) {
        }
    }

    class Car {
        // Fields
        // Complex Type
        // unless will be transpiled
        private _engine: Engine;
        // here could be an Interface IEngine - anything that implements IEngine
        // but we should cast it to <Engine> if it's public field


        // public
        // could be generated by any 'public' keyword
        pubEngine: Engine;

        // Function props
        static log: (msg: any, ...optParams: any[]) => void = console.log;

        // Contructor
        // in case of object we can use destructuring
        constructor(engine: Engine /*here could be an Interface IEngine*/) {
            this.engine = engine;
        }

        // Functions/Methods
        start(): void {
            Car.log('Started' + this._engine.engineType);
        }

        // Properties
        get engine(): Engine {
            return this._engine;
        }

        set engine(val: Engine) {
            if (val == undefined) {
                throw 'Supply an Engine!';
            }
            this._engine = val;
        }
    }
}

/*
 * Abstract and interfaces
 * */
{
    interface ISprite {
        x: number;
        y: number;
        imgUrl: string;

        update: () => void;

        name: string;
    }

    abstract class Sprite implements ISprite {
        x: number;
        y: number;
        imgUrl: string;

        abstract update(): void;

        name = '123';
    }

    class Player extends Sprite {
        update() {

        }
    }

    class Monster extends Sprite {
        update() {

        }
    }

    const p = new Player();
}

/*
 * Casting types
 * */
{
    let table: HTMLTableElement =
        <HTMLTableElement>document.createElement('table');
}

/*
 *
 * */
{

}